## Домашнее задание к занятию «Многопоточность»

### Задание 1

#### Очередь клиентов
<details>
Вам нужно создать приложение, которое имитирует очередь в окошко. Для этого нужно создать два потока, работающие с одной разделяемой переменной.

Первый поток имитирует клиента: раз в секунду он обращается к счётчику клиентов и увеличивает его на 1. Максимальное количество клиентов должно быть параметризировано.

Второй поток имитирует операциониста: раз в 2 секунды он обращается к счётчику клиентов и уменьшает его на 1. «Операционист» работает до последнего клиента.
</details>

### Задание 2

#### Параллельные вычисления
<details>
- Напишите программу для расчёта суммы двух векторов.
- Распараллельте эту программу на 2, 4, 8 и 16 потоков.
- Определите, какое количество потоков даёт самый быстрый результат.
- Сравните результаты выполнения для массивов из 1 000, 10 000, 100 000 и 1 000 000 элементов.
- Время выполнения для каждого варианта сведите в таблицу и выведите её в консоль.
- Первый запущенный поток должен вывести на экран доступное количество аппаратных ядер.

![](./pic1.png)
</details>
___________________________________________________________________________________________________

## Домашнее задание к занятию «Конкуренция, состояние гонки»

### Задание 1

#### Атомарная очередь клиентов
<details>
Нужно модифицировать [задание 1 к первому уроку](https://github.com/netology-code/map-homeworks/tree/main/01) так, чтобы счётчик клиентов был атомарным.<br/>
Все операции со счётчиков должны быть атомарными.<br/>
Проверьте работу различными способами упорядочения доступа к памяти.

</details>

### Задание 2

#### Прогресс-бар
<details>
Создайте консольное приложение для имитации многопоточного расчёта.<br/>
Количество потоков, длина расчёта должны быть заданы переменными.<br/>
В консоль во время работы программы должны построчно для каждого потока выводиться:

	• номер потока по порядку;
	
	• идентификатор потока;
	
	• заполняющийся индикатор наподобие прогресс-бара, визуализирующий процесс «расчёта»;
	
	• после завершения работы каждого потока в соответствующей строке суммарное время, затраченное на работу потока.
 
 Строки прогресс-баров каждого потока должны выводиться одновремено. Время появления каждого нового символа в строке прогресс-бара подберите так, чтобы процесс заполнения строки был виден. Пример работы программы [по ссылке.]( https://cloud.mail.ru/public/MZVL/AqpmAkcMp)


#### Дополнение к заданию 2*

Во время очередной итерации «расчёта» сымитируйте со случайной вероятностью возникновение ошибки (exception), которая не должна приводить к прекращению работы потока или программы. При этом этот факт должен визуализироваться отдельным цветом на прогресс-баре.
</details>

### Задание 3

#### Защищённый обмен данными
<details>
- Создайте класс Data, содержащий в качестве полей скалярные данные и мьютекс.
- Создайте функцию swap, которая принимает ссылки на два объекта класса Data и обменивает их местами.<br/>
- В функциях нужно сначала захватить мьютексы обоих объектов, а затем выполнить обмен данными.
- Реализуйте три варианта этой функции: при помощи lock, scoped_lock и unique_lock.
  </details>

___________________________________________________________________________________________________
## Домашнее задание к занятию «Асинхронное программирование»

### Задание 1
#### Сортировка выбором
<details>
Реализуйте алгоритм сортировки выбором.
Сортировка выбором состоит в том, что в неупорядоченном списке находится наименьший элемент. Выбранный в исходном списке минимальный элемент записывается на i-е место исходного списка (i=1,2,…,п), а элемент с i-го места — на место выбранного. При этом очевидно, что уже упорядоченные элементы, а они будут расположены, начиная с первого места, исключаются из дальнейшей сортировки, поэтому длина списка, участвующего в каждом последующем просмотре, должна быть на один элемент меньше предыдущего.
Поиск минимального элемента реализуйте в виде асинхронной задачи.
Результат должен возвращаться в основной поток через связку std::promise-std::future.
</details>
 
### Задание 2
#### Реализуйте параллельный вариант оператора for_each.
<details>
Функция должна принимать итераторы на начало и конец контейнера и ссылку, обрабатывающую функцию.
При реализации нужно рекурсивно разделить контейнер на несколько блоков и для каждого запустить отдельную задачу, применяющую обрабатывающую функцию к части контейнера.
</details>

___________________________________________________________________________________________________
## Домашнее задание к занятию «Рефакторинг»

### Задание 1
#### Геометрические фигуры
<details>
Представлен класс, описывающий геометрические фигуры:

* линия,
* прямоугольник,
* параллелепипед,
* окружность,
* цилиндр.

Класс, описывающий геометрические преобразования фигур:

* смещения по осям x, y, z;
* масштабирование по отдельным осям;
* полное масштабирование.

Нужно выделить из кода «плохие запахи» и провести рефакторинг кода, приведя его к корректному виду.
</details>
 
